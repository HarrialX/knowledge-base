Original Source:
https://github.com/http4s/http4s/commit/987d6589ef79545b9bb2324ac4bdebf82d9a0171

Commit history:

  @@ -38,7 +38,6 @@ import org.http4s.blaze.channel.{
   SocketConnection
  }
  import org.http4s.blaze.channel.nio1.NIO1SocketServerGroup
- import org.http4s.blaze.channel.nio2.NIO2SocketServerGroup
  import org.http4s.blaze.http.http2.server.ALPNServerSelector
  import org.http4s.blaze.pipeline.LeafBuilder
  import org.http4s.blaze.pipeline.stages.SSLStage
  @@ -86,13 +85,13 @@ import scodec.bits.ByteVector
    *    this is necessary to recover totality from the error condition.
    * @param banner: Pretty log to display on server start. An empty sequence
    *    such as Nil disables this
+   * @param maxConnections: The maximum number of client connections that may be active at any time.
   */
- class BlazeServerBuilder[F[_]](
+ class BlazeServerBuilder[F[_]] private (
   socketAddress: InetSocketAddress,
   executionContext: ExecutionContext,
   responseHeaderTimeout: Duration,
   idleTimeout: Duration,
-  isNio2: Boolean,
   connectorPoolSize: Int,
   bufferSize: Int,
   selectorThreadFactory: ThreadFactory,
  @@ -105,6 +104,7 @@ class BlazeServerBuilder[F[_]](
   httpApp: HttpApp[F],
   serviceErrorHandler: ServiceErrorHandler[F],
   banner: immutable.Seq[String],
+  maxConnections: Int,
   val channelOptions: ChannelOptions
  )(implicit protected val F: Async[F])
   extends ServerBuilder[F]
  @@ -118,7 +118,6 @@ class BlazeServerBuilder[F[_]](
   executionContext: ExecutionContext = executionContext,
   idleTimeout: Duration = idleTimeout,
   responseHeaderTimeout: Duration = responseHeaderTimeout,
-  isNio2: Boolean = isNio2,
   connectorPoolSize: Int = connectorPoolSize,
   bufferSize: Int = bufferSize,
   selectorThreadFactory: ThreadFactory = selectorThreadFactory,
  @@ -131,14 +130,14 @@ class BlazeServerBuilder[F[_]](
   httpApp: HttpApp[F] = httpApp,
   serviceErrorHandler: ServiceErrorHandler[F] = serviceErrorHandler,
   banner: immutable.Seq[String] = banner,
+  maxConnections: Int = maxConnections,
   channelOptions: ChannelOptions = channelOptions
    ): Self =
   new BlazeServerBuilder(
        socketAddress,
        executionContext,
        responseHeaderTimeout,
        idleTimeout,
-       isNio2,
        connectorPoolSize,
        bufferSize,
        selectorThreadFactory,
  @@ -151,6 +150,7 @@ class BlazeServerBuilder[F[_]](
        httpApp,
        serviceErrorHandler,
        banner,
+       maxConnections,
        channelOptions
      )
  
  @@ -219,8 +219,6 @@ class BlazeServerBuilder[F[_]](
   def withSelectorThreadFactory(selectorThreadFactory: ThreadFactory): Self =
      copy(selectorThreadFactory = selectorThreadFactory)
  
-  def withNio2(isNio2: Boolean): Self = copy(isNio2 = isNio2)
- 
   def withWebSockets(enableWebsockets: Boolean): Self =
      copy(enableWebSockets = enableWebsockets)
  
  @@ -247,6 +245,9 @@ class BlazeServerBuilder[F[_]](
   def withChunkBufferMaxSize(chunkBufferMaxSize: Int): BlazeServerBuilder[F] =
      copy(chunkBufferMaxSize = chunkBufferMaxSize)
  
+  def withMaxConnections(maxConnections: Int): BlazeServerBuilder[F] =
+     copy(maxConnections = maxConnections)
+ 
   private def pipelineFactory(
   scheduler: TickWheelExecutor,
   engineConfig: Option[(SSLContext, SSLEngine => Unit)],
  @@ -343,12 +344,8 @@ class BlazeServerBuilder[F[_]](
   else address
  
   val mkFactory: Resource[F, ServerChannelGroup] = Resource.make(F.delay {
-  if (isNio2)
-  NIO2SocketServerGroup
-           .fixedGroup(connectorPoolSize, bufferSize, channelOptions, selectorThreadFactory)
-  else
-  NIO1SocketServerGroup
-           .fixedGroup(connectorPoolSize, bufferSize, channelOptions, selectorThreadFactory)
+  NIO1SocketServerGroup
+         .fixed(connectorPoolSize, bufferSize, channelOptions, selectorThreadFactory, maxConnections)
      })(factory => F.delay(factory.closeGroup()))
  
   def mkServerChannel(
  @@ -415,7 +412,6 @@ object BlazeServerBuilder {
        executionContext = executionContext,
        responseHeaderTimeout = defaults.ResponseTimeout,
        idleTimeout = defaults.IdleTimeout,
-       isNio2 = false,
        connectorPoolSize = DefaultPoolSize,
        bufferSize = 64 * 1024,
        selectorThreadFactory = defaultThreadSelectorFactory,
  @@ -428,6 +424,7 @@ object BlazeServerBuilder {
        httpApp = defaultApp[F],
        serviceErrorHandler = DefaultServiceErrorHandler[F],
        banner = defaults.Banner,
+       maxConnections = defaults.MaxConnections,
        channelOptions = ChannelOptions(Vector.empty)
      )
  
  
  @@ -83,7 +83,6 @@ lazy val core = libraryProject("core")
    .enablePlugins(
   BuildInfoPlugin,
   MimeLoaderPlugin,
-  NowarnCompatPlugin,
    )
    .settings(
      description := "Core http4s library for servers and clients",
  @@ -113,7 +112,6 @@ lazy val core = libraryProject("core")
        )
      },
      unusedCompileDependenciesFilter -= moduleFilter("org.scala-lang", "scala-reflect"),
-  Compile / packageBin / mappings ~= { _.filterNot(_._2.startsWith("scala/")) },
    )
  
  lazy val laws = libraryProject("laws")
  @@ -175,7 +173,6 @@ lazy val tests = libraryProject("tests")
    .dependsOn(core, specs2 % "test->test")
  
  lazy val server = libraryProject("server")
-   .enablePlugins(NowarnCompatPlugin)
    .settings(
      description := "Base library for building http4s servers",
      startYear := Some(2014),
  @@ -209,7 +206,6 @@ lazy val prometheusMetrics = libraryProject("prometheus-metrics")
    )
  
  lazy val client = libraryProject("client")
-   .enablePlugins(NowarnCompatPlugin)
    .settings(
      description := "Base library for building http4s clients",
      startYear := Some(2014),
  @@ -286,6 +282,10 @@ lazy val blazeServer = libraryProject("blaze-server")
    .settings(
      description := "blaze implementation for http4s servers",
      startYear := Some(2014),
+     mimaBinaryIssueFilters ++= Seq(
+  // privat constructor with new parameter
+  ProblemFilters.exclude[DirectMissingMethodProblem]("org.http4s.server.blaze.BlazeServerBuilder.this")
+     )
    )
    .dependsOn(blazeCore % "compile;test->test", server % "compile;test->test")
  
  
  @@ -73,7 +73,7 @@ class FollowRedirectSuite extends Http4sSuite with Http4sClientDsl[IO] {
   val req = Request[IO](PUT, uri"http://localhost/303").withEntity("foo")
      client
        .run(req)
-       .use { case Ok(resp) =>
+       .use { case resp =>
          resp.headers.get(CIString("X-Original-Content-Length")).map(_.value).pure[IO]
        }
        .map(_.get)
  @@ -128,7 +128,7 @@ class FollowRedirectSuite extends Http4sSuite with Http4sClientDsl[IO] {
   Header("Authorization", "Bearer s3cr3t"))
      client
        .run(req)
-       .use { case Ok(resp) =>
+       .use { case resp =>
          resp.headers.get(CIString("X-Original-Authorization")).map(_.value).pure[IO]
        }
        .assertEquals(Some(""))
  @@ -141,7 +141,7 @@ class FollowRedirectSuite extends Http4sSuite with Http4sClientDsl[IO] {
   Header("Authorization", "Bearer s3cr3t"))
      client
        .run(req)
-       .use { case Ok(resp) =>
+       .use { case resp =>
          resp.headers.get(CIString("X-Original-Authorization")).map(_.value).pure[IO]
        }
        .assertEquals(Some("Bearer s3cr3t"))
  @@ -150,7 +150,7 @@ class FollowRedirectSuite extends Http4sSuite with Http4sClientDsl[IO] {
    test("FollowRedirect should Record the intermediate URIs") {
      client
        .run(Request[IO](uri = uri"http://localhost/loop/0"))
-       .use { case Ok(resp) =>
+       .use { resp =>
   IO.pure(FollowRedirect.getRedirectUris(resp))
        }
        .assertEquals(
  @@ -164,7 +164,7 @@ class FollowRedirectSuite extends Http4sSuite with Http4sClientDsl[IO] {
    test("FollowRedirect should Not add any URIs when there are no redirects") {
      client
        .run(Request[IO](uri = uri"http://localhost/loop/100"))
-       .use { case Ok(resp) =>
+       .use { case resp =>
   IO.pure(FollowRedirect.getRedirectUris(resp))
        }
        .assertEquals(List.empty[Uri])
  
