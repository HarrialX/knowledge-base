Original Source:
https://github.com/httplib2/httplib2/commit/bd9ee252c8f099608019709e22c0d705e98d26bc

Commit history:

  @@ -0,0 +1,61 @@
+ import base64
+ import re
+ 
+ import pyparsing as pp
                This comment has been minimized.

        

Sign in to view
















              Copy link
            

              Quote reply
            









ptmcg



Mar 27, 2021




      Contributor
    


pyparsing 2.4.7 is Py2 and Py3 compatible. It may be worth splitting the parser out to a separate module that both your P2 and Py3 versions import.














              This comment has been minimized.

        

Sign in to view
















              Copy link
            

              Quote reply
            









temoto



Mar 29, 2021




  Author


      Member
    


Thanks, we're committed to drop Python2 support altogether and then will use something like pyparsing>=3 to put lesser version constraint on projects.
+ 
+ from .error import *
+ 
+ UNQUOTE_PAIRS = re.compile(r"\\(.)")
+ unquote = lambda s, l, t: UNQUOTE_PAIRS.sub(r"\1", t[0][1:-1])
+ 
+ # https://tools.ietf.org/html/rfc7235#section-1.2
+ # https://tools.ietf.org/html/rfc7235#appendix-B
+ tchar = "!#$%&'*+-.^_`|~" + pp.nums + pp.alphas
+ token = pp.Word(tchar).setName("token")
+ token68 = pp.Combine(pp.Word("-._~+/" + pp.nums + pp.alphas) + pp.ZeroOrMore("=")).setName("token68")
                This comment has been minimized.

        

Sign in to view
















              Copy link
            

              Quote reply
            









ptmcg



Mar 27, 2021




      Contributor
    


pyparsing is not exactly fast. I believe you would get better performance using a pp.Word('=') in place of the pp.ZeroOrMore("=") . Note that this will use a regex internally.
Also, pyparsing's whitespace skipping will accept token68's that look like "0 = = =". If that is not permissable, then use leaveWhitespace() on the second term in this expression (either ZeroOrMore or Word).







👍
              1
            













              This comment has been minimized.

        

Sign in to view
















              Copy link
            

              Quote reply
            









temoto



Mar 29, 2021




  Author


      Member
    


@ptmcg thanks. Does it need to be pp.Optional(pp.Word("=")) to accept string with zero length suffix?














              This comment has been minimized.

        

Sign in to view
















              Copy link
            

              Quote reply
            









ptmcg



Mar 29, 2021




      Contributor
    


Yes.
+ 
+ quoted_string = pp.dblQuotedString.copy().setName("quoted-string").setParseAction(unquote)
+ auth_param_name = token.copy().setName("auth-param-name").addParseAction(pp.downcaseTokens)
+ auth_param = auth_param_name + pp.Suppress("=") + (token ^ quoted_string)
                This comment has been minimized.

        

Sign in to view
















              Copy link
            

              Quote reply
            









ptmcg



Mar 27, 2021




      Contributor
    


I don't think there is any ambiguity between token and quoted_string such that you need "^" operator. I think you can safely replace with "|", and gain some parse-time performance.














              This comment has been minimized.

        

Sign in to view
















              Copy link
            

              Quote reply
            









temoto



Mar 29, 2021




  Author


      Member
    


This works, improvement is 940us -> 730us (~20%) for params.parseString of a realistic digest auth params. Thank you.
+ params = pp.Dict(pp.delimitedList(pp.Group(auth_param)))
+ 
+ scheme = token("scheme")
+ challenge = scheme + (token68("token") ^ params("params"))
                This comment has been minimized.

        

Sign in to view
















              Copy link
            

              Quote reply
            









ptmcg



Mar 27, 2021




      Contributor
    


'^' operators can also be expensive, since they always check all alternatives, and then select the longest. I think you will get suitable and slightly better behavior if you use (params("params") | token68("token")) instead. (Depends on how often you get a params in the input string).














              This comment has been minimized.

        

Sign in to view
















              Copy link
            

              Quote reply
            









temoto



Mar 29, 2021




  Author


      Member
    


This works only with params first and successfully produces wrong results with token first. Maybe syntax is genuinely ambiguous or my implementation is bad. Improvement is 1220us -> 630us (~50%) for challenge.parseString on synthetic complex line. Thank you.
+ 
+ authentication_info = params.copy()
+ www_authenticate = pp.delimitedList(pp.Group(challenge))
+ 
+ 
+ def _parse_authentication_info(headers, headername="authentication-info"):
+  """https://tools.ietf.org/html/rfc7615
+     """
+  header = headers.get(headername, "").strip()
+  if not header:
+  return {}
        Check warning
        on line 34 in python2/httplib2/auth.py
    








      Codecov / codecov/patch



        python2/httplib2/auth.py#L34
      


Added line #L34 was not covered by tests
+  try:
+  parsed = authentication_info.parseString(header)
+  except pp.ParseException as ex:
        Check warning
        on line 37 in python2/httplib2/auth.py
    








      Codecov / codecov/patch



        python2/httplib2/auth.py#L37
      


Added line #L37 was not covered by tests
+  # print(ex.explain(ex))
+  raise MalformedHeader(headername)
        Check warning
        on line 39 in python2/httplib2/auth.py
    








      Codecov / codecov/patch



        python2/httplib2/auth.py#L39
      


Added line #L39 was not covered by tests
+ 
+  return parsed.asDict()
+ 
+ 
+ def _parse_www_authenticate(headers, headername="www-authenticate"):
+  """Returns a dictionary of dictionaries, one dict per auth_scheme."""
+  header = headers.get(headername, "").strip()
+  if not header:
+  return {}
+  try:
+  parsed = www_authenticate.parseString(header)
+  except pp.ParseException as ex:
+  # print(ex.explain(ex))
+  raise MalformedHeader(headername)
+ 
+  retval = {
+  challenge["scheme"].lower(): challenge["params"].asDict()
+  if "params" in challenge
+  else {"token": challenge.get("token")}
+  for challenge in parsed
+     }
+  return retval
  @@ -0,0 +1,48 @@
+ # All exceptions raised here derive from HttpLib2Error
+ class HttpLib2Error(Exception):
+  pass
+ 
+ 
+ # Some exceptions can be caught and optionally
+ # be turned back into responses.
+ class HttpLib2ErrorWithResponse(HttpLib2Error):
+  def __init__(self, desc, response, content):
+  self.response = response
+  self.content = content
+  HttpLib2Error.__init__(self, desc)
        Check warning
        on line 12 in python2/httplib2/error.py
    








      Codecov / codecov/patch



        python2/httplib2/error.py#L10-L12
      


Added lines #L10 - L12 were not covered by tests
+ 
+ 
+ class RedirectMissingLocation(HttpLib2ErrorWithResponse):
+  pass
+ 
+ 
+ class RedirectLimit(HttpLib2ErrorWithResponse):
+  pass
+ 
+ 
+ class FailedToDecompressContent(HttpLib2ErrorWithResponse):
+  pass
+ 
+ 
+ class UnimplementedDigestAuthOptionError(HttpLib2ErrorWithResponse):
+  pass
+ 
+ 
+ class UnimplementedHmacDigestAuthOptionError(HttpLib2ErrorWithResponse):
+  pass
+ 
+ 
+ class MalformedHeader(HttpLib2Error):
+  pass
+ 
+ 
+ class RelativeURIError(HttpLib2Error):
+  pass
+ 
+ 
+ class ServerNotFoundError(HttpLib2Error):
+  pass
+ 
+ 
+ class ProxiesUnavailableError(HttpLib2Error):
+  pass
