Original Source:
https://github.com/uclouvain/openjpeg/commit/ef01f18dfc6780b776d0674ed3e7415c6ef54d24

Commit history:

  @@ -1241,7 +1241,7 @@ opj_pi_iterator_t *opj_pi_create_decode(opj_image_t *p_image,
  	l_current_pi->include = 00;
   if (l_step_l <= (SIZE_MAX / (l_tcp->numlayers + 1U)))
  	{
- 		l_current_pi->include = (OPJ_INT16*) opj_calloc((l_tcp->numlayers +1) * l_step_l, sizeof(OPJ_INT16));
+ 		l_current_pi->include = (OPJ_INT16*) opj_calloc((size_t)(l_tcp->numlayers + 1U) * l_step_l, sizeof(OPJ_INT16));
                This comment has been minimized.

        

Sign in to view
















              Copy link
            

              Quote reply
            









stweil



Sep 8, 2016

â€¢




            edited
        













      Contributor
    


I'd cast l_tcp->numlayers instead of the result of the addition. Otherwise the addition could overflow (resulting in 0). I admit that the chances that this will happen are very low. Or do we know that l_tcp->numlayers can never reach UINT32_MAX?














              This comment has been minimized.

        

Sign in to view
















              Copy link
            

              Quote reply
            









mayeut



Sep 8, 2016




  Author


      Collaborator
    


The latter. It might need a comment in source code to clarify that information though: https://github.com/uclouvain/openjpeg/blob/master/src/lib/openjp2/j2k.c#L2546
If this wasn't the case we would need an overflow check on the addition as well because on x86, SIZE_MAX == UINT32_MAX
  	}
  
   if
  
