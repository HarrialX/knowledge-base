Original Source:
https://github.com/bminor/glibc/commit/2864e767053317538feafa815046fff89e5a16be#diff-94e8c502f255fdfc346df0e29fd4ef40

Commit history:

  @@ -1,3 +1,55 @@
+ 1999-11-09  Ulrich Drepper  <drepper@cygnus.com>
+ 
+ 	* elf/dl-load.c (_dl_dst_count): Allow $ORIGIN to point to
+ 	directory with the reference since this is as secure as using the
+ 	object with the dependency.
+ 	(_dl_dst_substitute): Likewise.
+ 
+ 	* elf/dl-load.c (_dl_dst_count): Change strings in first two
+ 	strncmp calls to allow reuse.
+ 	(_dl_dst_substitute): Likewise.
+ 
+ 1999-11-01  Arnold D. Robbins  <arnold@skeeve.com>
+ 
+ 	* posix/regex.c (init_syntax_once): move below definition of
+ 	ISALNUM etc., then use ISALNUM to init the table, so that
+ 	the word ops will work if i18n'ed.
+ 	(SYNTAX): And subscript with 0xFF for 8bit character sets.
+ 
+ 1999-11-09  Andreas Jaeger  <aj@suse.de>
+ 
+ 	* sysdeps/unix/getlogin_r.c (getlogin_r): Sync with getlogin
+ 	implementation for ttyname_r call; fix inverted condition; return
+ 	ut_user.  Closes PR libc/1438.
+ 
+ 1999-11-09  Ulrich Drepper  <drepper@cygnus.com>
+ 
+ 	* timezone/checktab.awk: Update from tzcode1999h.
+ 	* timezone/africa: Update from tzdata1999i.
+ 	* timezone/asia: Likewise.
+ 	* timezone/australasia: Likewise.
+ 	* timezone/backward: Likewise.
+ 	* timezone/europe: Likewise.
+ 	* timezone/northamerica: Likewise.
+ 	* timezone/southamerica: Likewise.
+ 	* timezone/iso3166.tab: Likewise.
+ 	* timezone/zone.tab: Likewise.
+ 
+ 	* sysdeps/unix/sysv/linux/bits/resource.h: Define values also as
+ 	macros.  Patch by brg@csua.berkeley.edu [PR libc/1439].
+ 
+ 1999-11-09  Andreas Jaeger  <aj@suse.de>
+ 
+ 	* posix/Makefile (tests): Added tst-getlogin.
+ 
+ 	* posix/tst-getlogin.c: New file, contains simple tests for
+ 	getlogin and getlogin_r.
+ 
+ 1999-11-09  Andreas Schwab  <schwab@suse.de>
+ 
+ 	* misc/syslog.c: For LOG_PERROR only append a newline if
+ 	necessary.
+ 
  1999-11-08  Ulrich Drepper  <drepper@cygnus.com>
  
  	* elf/elf.h: Add STT_REGISTER, STT_HP_OPAQUE, and STT_ST_STUB
  
  @@ -149,21 +149,31 @@ local_strdup (const char *s)
  size_t
  _dl_dst_count (const char *name, int is_path)
  {
+  const char *const start = name;
   size_t cnt = 0;
  
   do
      {
   size_t len = 1;
  
-  /* $ORIGIN is not expanded for SUID/GUID programs.  */
-  if ((((!__libc_enable_secure
- 	     && strncmp (&name[1], "ORIGIN", 6) == 0 && (len = 7) != 0)
- 	    || (strncmp (&name[1], "PLATFORM", 8) == 0 && (len = 9) != 0))
+  /* $ORIGIN is not expanded for SUID/GUID programs.
+ 
+ 	 Note that it is no bug that the strings in the first two `strncmp'
+ 	 calls are longer than the sequence which is actually tested.  */
+  if ((((strncmp (&name[1], "ORIGIN}", 6) == 0
+ 	     && (!__libc_enable_secure
+ 		 || ((name[7] == '\0' || (is_path && name[7] == ':'))
+ 		     && (name == start || (is_path && name[-1] == ':'))))
+ 	     && (len = 7) != 0)
+ 	    || (strncmp (&name[1], "PLATFORM}", 8) == 0 && (len = 9) != 0))
  	   && (name[len] == '\0' || name[len] == '/'
  	       || (is_path && name[len] == ':')))
  	  || (name[1] == '{'
- 	      && ((!__libc_enable_secure
- 		   && strncmp (&name[2], "ORIGIN}", 7) == 0 && (len = 9) != 0)
+ 	      && ((strncmp (&name[2], "ORIGIN}", 7) == 0
+ 		   && (!__libc_enable_secure
+ 		       || ((name[9] == '\0' || (is_path && name[9] == ':'))
+ 			   && (name == start || (is_path && name[-1] == ':'))))
+ 		   && (len = 9) != 0)
  		  || (strncmp (&name[2], "PLATFORM}", 9) == 0
  		      && (len = 11) != 0))))
  	++cnt;
  @@ -180,6 +190,7 @@ char *
  _dl_dst_substitute (struct link_map *l, const char *name, char *result,
   int is_path)
  {
+  const char *const start = name;
   char *last_elem, *wp;
  
   /* Now fill the result path.  While copying over the string we keep
  @@ -195,8 +206,10 @@ _dl_dst_substitute (struct link_map *l, const char *name, char *result,
   const char *repl;
   size_t len;
  
-  if ((((strncmp (&name[1], "ORIGIN", 6) == 0 && (len = 7) != 0)
- 		|| (strncmp (&name[1], "PLATFORM", 8) == 0 && (len = 9) != 0))
+  /* Note that it is no bug that the strings in the first two `strncmp'
+ 	 calls are longer than the sequence which is actually tested.  */
+  if ((((strncmp (&name[1], "ORIGIN}", 6) == 0 && (len = 7) != 0)
+ 		|| (strncmp (&name[1], "PLATFORM}", 8) == 0 && (len = 9) != 0))
  	       && (name[len] == '\0' || name[len] == '/'
  		   || (is_path && name[len] == ':')))
  	      || (name[1] == '{'
  @@ -205,7 +218,12 @@ _dl_dst_substitute (struct link_map *l, const char *name, char *result,
  			  && (len = 11) != 0))))
  	    {
  	      repl = ((len == 7 || name[2] == 'O')
- 		      ? (__libc_enable_secure ? NULL : l->l_origin)
+ 		      ? (__libc_enable_secure
+ 			 && ((name[len] != '\0'
+ 			      && (!is_path || name[len] != ':'))
+ 			     || (name != start
+ 				 && (!is_path || name[-1] != ':')))
+ 			 ? NULL : l->l_origin)
  		      : _dl_platform);
  
   if (repl != NULL && repl != (const char *) -1)
  @@ -259,7 +277,7 @@ expand_dynamic_string_token (struct link_map *l, const char *s)
   size_t total;
   char *result;
  
-  /* Determine the nubmer of DST elements.  */
+  /* Determine the number of DST elements.  */
    cnt = DL_DST_COUNT (s, 1);
  
   /* If we do not have to replace anything simply copy the string.  */
  
  @@ -475,9 +475,11 @@ elements.
  To remove a specific element matching @var{key} from the tree
  @code{tdelete} can be used.  It locates the matching element using the
  same method as @code{tfind}.  The corresponding element is then removed
- and the data if this tree node is returned by the function.  If there is
- no matching entry in the tree nothing can be deleted and the function
- returns @code{NULL}.
+ and a pointer to the parent of the deleted node is returned by the
+ function.  If there is no matching entry in the tree nothing can be
+ deleted and the function returns @code{NULL}.  If the root of the tree
+ is deleted @code{tdelete} returns some unspecified value not equal to
+ @code{NULL}.
  @end deftypefun
  
  @comment search.h
  
  @@ -177,10 +177,14 @@ vsyslog(pri, fmt, ap)
  
  		v->iov_base = buf + msgoff;
  		v->iov_len = bufsize - msgoff;
- 		++v;
- 		v->iov_base = (char *) "\n";
- 		v->iov_len = 1;
- 		(void)__writev(STDERR_FILENO, iov, 2);
+  /* Append a newline if necessary.  */
+  if (buf[bufsize - 1] != '\n')
+ 		  {
+ 		    ++v;
+ 		    v->iov_base = (char *) "\n";
+ 		    v->iov_len = 1;
+ 		  }
+ 		(void)__writev(STDERR_FILENO, iov, v - iov + 1);
  	}
  
   /* Prepare for multiple users.  We have to take care: open and
  
  @@ -57,7 +57,7 @@ include ../Makeconfig
  
  aux		:= init-posix environ
  tests		:= tstgetopt testfnm runtests runptests	     \
- 		   tst-preadwrite test-vfork regexbug1
+ 		   tst-preadwrite test-vfork regexbug1 tst-getlogin
  ifeq (yes,$(build-shared))
  test-srcs	:= globtest
  tests           += wordexp-test
  
  @@ -164,46 +164,6 @@ char *realloc ();
  #  define SWITCH_ENUM_CAST(x) (x)
  # endif
  
- /* How many characters in the character set.  */
- # define CHAR_SET_SIZE 256
- 
- # ifdef SYNTAX_TABLE
- 
- extern char *re_syntax_table;
- 
- # else /* not SYNTAX_TABLE */
- 
- static char re_syntax_table[CHAR_SET_SIZE];
- 
- static void
- init_syntax_once ()
- {
-  register int c;
-  static int done;
- 
-  if (done)
-  return;
- 
-  bzero (re_syntax_table, sizeof re_syntax_table);
- 
-  for (c = 'a'; c <= 'z'; c++)
-      re_syntax_table[c] = Sword;
- 
-  for (c = 'A'; c <= 'Z'; c++)
-      re_syntax_table[c] = Sword;
- 
-  for (c = '0'; c <= '9'; c++)
-      re_syntax_table[c] = Sword;
- 
-    re_syntax_table['_'] = Sword;
- 
-    done = 1;
- }
- 
- # endif /* not SYNTAX_TABLE */
- 
- # define SYNTAX(c) re_syntax_table[c]
- 
  #endif /* not emacs */
  
  /* Get the interface, including the syntax bits.  */
  @@ -276,6 +236,43 @@ init_syntax_once ()
  # define SIGN_EXTEND_CHAR(c) ((((unsigned char) (c)) ^ 128) - 128)
  #endif
  
+ #ifndef emacs
+ /* How many characters in the character set.  */
+ # define CHAR_SET_SIZE 256
+ 
+ # ifdef SYNTAX_TABLE
+ 
+ extern char *re_syntax_table;
+ 
+ # else /* not SYNTAX_TABLE */
+ 
+ static char re_syntax_table[CHAR_SET_SIZE];
+ 
+ static void
+ init_syntax_once ()
+ {
+  register int c;
+  static int done = 0;
+ 
+  if (done)
+  return;
+  bzero (re_syntax_table, sizeof re_syntax_table);
+ 
+  for (c = 0; c < CHAR_SET_SIZE; ++c)
+  if (ISALNUM (c))
+ 	re_syntax_table[c] = Sword;
+ 
+    re_syntax_table['_'] = Sword;
+ 
+    done = 1;
+ }
+ 
+ # endif /* not SYNTAX_TABLE */
+ 
+ # define SYNTAX(c) re_syntax_table[((c) & 0xFF)]
+ 
+ #endif /* emacs */
+ 
  /* Should we use malloc or alloca?  If REGEX_MALLOC is not defined, we
     use `alloca' instead of `malloc'.  This is because using malloc in
     re_search* or re_match* could cause memory leaks when C-g is used in
  
  @@ -0,0 +1,58 @@
+ /* Copyright (C) 1999 Free Software Foundation, Inc.
+    This file is part of the GNU C Library.
+ 
+    The GNU C Library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public License as
+    published by the Free Software Foundation; either version 2 of the
+    License, or (at your option) any later version.
+ 
+    The GNU C Library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+ 
+    You should have received a copy of the GNU Library General Public
+    License along with the GNU C Library; see the file COPYING.LIB.  If not,
+    write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+    Boston, MA 02111-1307, USA.  */
+ 
+ #include <unistd.h>
+ #include <stdio.h>
+ #include <string.h>
+ 
+ int
+ main (void)
+ {
+  char *login;
+  int errors = 0;
+ 
+   login = getlogin ();
+  if (login == NULL)
+  puts ("getlogin returned NULL, no further tests");
+  else
+     {
+  char name[1024];
+  int ret;
+ 
+  printf ("getlogin returned: `%s'\n", login);
+ 
+       ret = getlogin_r (name, sizeof (name));
+  if (ret == 0)
+ 	{
+  printf ("getlogin_r returned: `%s'\n", name);
+  if (strcmp (name, login) != 0)
+ 	    {
+  puts ("Error: getlogin and getlogin_r returned different names");
+ 	      ++errors;
+ 	    }
+ 	}
+  else
+ 	{
+  printf ("Error: getlogin_r returned: %d (%s)\n",
+ 		  ret, strerror (ret));
+ 	  ++errors;
+ 	}
+     }
+ 
+  return errors != 0;
+ }
  @@ -40,20 +40,20 @@ getlogin_r (name, name_len)
   int result = 0;
   struct utmp *ut, line, buffer;
  
-   {
-  int d = __open ("/dev/tty", 0);
-  if (d < 0)
-  return errno;
+  /* Get name of tty connected to fd 0.  Return if not a tty or
+      if fd 0 isn't open.  Note that a lot of documentation says that
+      getlogin() is based on the controlling terminal---what they
+      really mean is "the terminal connected to standard input".  The
+      getlogin() implementation of DEC Unix, SunOS, Solaris, HP-UX all
+      return NULL if fd 0 has been closed, so this is the compatible
+      thing to do.  Note that ttyname(open("/dev/tty")) on those
+      systems returns /dev/tty, so that is not a possible solution for
+      getlogin().  */
  
-     result = __ttyname_r (d, real_tty_path, sizeof (tty_pathname));
-     (void) __close (d);
- 
-  if (result != 0)
-       {
-  __set_errno (result);
-  return result;
-       }
-   }
+   result = __ttyname_r (0, real_tty_path, sizeof (tty_pathname));
+ 
+  if (result != 0)
+  return result;
  
    real_tty_path += 5;		/* Remove "/dev/".  */
  
  @@ -69,16 +69,16 @@ getlogin_r (name, name_len)
      }
   else
      {
-  size_t needed = strlen (ut->ut_line) + 1;
+  size_t needed = strlen (ut->ut_user) + 1;
  
-  if (needed < name_len)
+  if (needed > name_len)
  	{
   __set_errno (ERANGE);
  	  result = ERANGE;
  	}
   else
  	{
-  memcpy (name, ut->ut_line, needed);
+  memcpy (name, ut->ut_user, needed);
  	  result = 0;
  	}
      }
  
  @@ -219,6 +219,9 @@ struct rusage
  enum __priority_which
  {
    PRIO_PROCESS = 0,		/* WHO is a process ID.  */
+ #define PRIO_PROCESS PRIO_PROCESS
    PRIO_PGRP = 1,		/* WHO is a process group ID.  */
+ #define PRIO_PGRP PRIO_PGRP
    PRIO_USER = 2 /* WHO is a user ID.  */
+ #define PRIO_USER PRIO_USER
  };
