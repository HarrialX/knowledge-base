Original Source:
https://github.com/ceph/ceph/commit/5ead97120e07054d80623dada90a5cc764c28468

Commit history:

  @@ -136,6 +136,11 @@ struct AuthAuthorizer {
   explicit AuthAuthorizer(__u32 p) : protocol(p) {}
   virtual ~AuthAuthorizer() {}
   virtual bool verify_reply(bufferlist::iterator& reply) = 0;
+  virtual bool add_challenge(CephContext *cct, bufferlist& challenge) = 0;
+ };
+ 
+ struct AuthAuthorizerChallenge {
+  virtual ~AuthAuthorizerChallenge() {}
  };
  
  
  
  @@ -34,7 +34,9 @@ struct AuthAuthorizeHandler {
   virtual bool verify_authorizer(CephContext *cct, KeyStore *keys,
  				 bufferlist& authorizer_data, bufferlist& authorizer_reply,
                                   EntityName& entity_name, uint64_t& global_id,
- 				 AuthCapsInfo& caps_info, CryptoKey& session_key, uint64_t *auid = NULL) = 0;
+ 				 AuthCapsInfo& caps_info, CryptoKey& session_key,
+  uint64_t *auid,
+ 				 std::unique_ptr<AuthAuthorizerChallenge> *challenge) = 0;
   virtual int authorizer_session_crypto() = 0;
  };
  
  
  @@ -6,9 +6,12 @@
  
  
  
- bool CephxAuthorizeHandler::verify_authorizer(CephContext *cct, KeyStore *keys,
- 					      bufferlist& authorizer_data, bufferlist& authorizer_reply,
-                                               EntityName& entity_name, uint64_t& global_id, AuthCapsInfo& caps_info, CryptoKey& session_key,  uint64_t *auid)
+ bool CephxAuthorizeHandler::verify_authorizer(
+   CephContext *cct, KeyStore *keys,
+   bufferlist& authorizer_data, bufferlist& authorizer_reply,
+   EntityName& entity_name, uint64_t& global_id, AuthCapsInfo& caps_info,
+   CryptoKey& session_key, uint64_t *auid,
+   std::unique_ptr<AuthAuthorizerChallenge> *challenge)
  {
    bufferlist::iterator iter = authorizer_data.begin();
  
  @@ -19,7 +22,8 @@ bool CephxAuthorizeHandler::verify_authorizer(CephContext *cct, KeyStore *keys,
  
    CephXServiceTicketInfo auth_ticket_info;
  
-  bool isvalid = cephx_verify_authorizer(cct, keys, iter, auth_ticket_info, authorizer_reply);
+  bool isvalid = cephx_verify_authorizer(cct, keys, iter, auth_ticket_info, challenge,
+ 					 authorizer_reply);
  
   if (isvalid) {
      caps_info = auth_ticket_info.ticket.caps;
  
  @@ -23,7 +23,8 @@ struct CephxAuthorizeHandler : public AuthAuthorizeHandler {
   bool verify_authorizer(CephContext *cct, KeyStore *keys,
  			 bufferlist& authorizer_data, bufferlist& authorizer_reply,
                           EntityName& entity_name, uint64_t& global_id,
- 			 AuthCapsInfo& caps_info, CryptoKey& session_key, uint64_t *auid = NULL) override;
+ 			 AuthCapsInfo& caps_info, CryptoKey& session_key, uint64_t *auid,
+ 			 std::unique_ptr<AuthAuthorizerChallenge> *challenge) override;
   int authorizer_session_crypto() override;
  };
  
  
  @@ -304,6 +304,7 @@ CephXAuthorizer *CephXTicketHandler::build_authorizer(uint64_t global_id) const
   ::encode(service_id, a->bl);
  
   ::encode(ticket, a->bl);
+   a->base_bl = a->bl;
  
    CephXAuthorize msg;
    msg.nonce = a->nonce;
  @@ -390,7 +391,9 @@ bool cephx_decode_ticket(CephContext *cct, KeyStore *keys, uint32_t service_id,
   */
  bool cephx_verify_authorizer(CephContext *cct, KeyStore *keys,
  			     bufferlist::iterator& indata,
- 			     CephXServiceTicketInfo& ticket_info, bufferlist& reply_bl)
+ 			     CephXServiceTicketInfo& ticket_info,
+ 			     std::unique_ptr<AuthAuthorizerChallenge> *challenge,
+ 			     bufferlist& reply_bl)
  {
    __u8 authorizer_v;
   uint32_t service_id;
  @@ -457,6 +460,30 @@ bool cephx_verify_authorizer(CephContext *cct, KeyStore *keys,
   return false;
    }
  
+  if (challenge) {
+  auto *c = static_cast<CephXAuthorizeChallenge*>(challenge->get());
+  if (!auth_msg.have_challenge || !c) {
+       c = new CephXAuthorizeChallenge;
+       challenge->reset(c);
+  get_random_bytes((char*)&c->server_challenge, sizeof(c->server_challenge));
+  ldout(cct,10) << __func__ << " adding server_challenge " << c->server_challenge
+ 		    << dendl;
+ 
+  encode_encrypt_enc_bl(cct, *c, ticket_info.session_key, reply_bl, error);
+  if (!error.empty()) {
+  ldout(cct, 10) << "verify_authorizer: encode_encrypt error: " << error << dendl;
+  return false;
+       }
+  return false;
+     }
+  ldout(cct, 10) << __func__ << " got server_challenge+1 "
+ 		   << auth_msg.server_challenge_plus_one
+ 		   << " expecting " << c->server_challenge + 1 << dendl;
+  if (c->server_challenge + 1 != auth_msg.server_challenge_plus_one) {
+  return false;
+     }
+   }
+ 
   /*
     * Reply authorizer:
     *  {timestamp + 1}^session_key
  @@ -493,3 +520,31 @@ bool CephXAuthorizer::verify_reply(bufferlist::iterator& indata)
   return true;
  }
  
+ bool CephXAuthorizer::add_challenge(CephContext *cct, bufferlist& challenge)
+ {
+   bl = base_bl;
+ 
+   CephXAuthorize msg;
+   msg.nonce = nonce;
+ 
+  auto p = challenge.begin();
+  if (!p.end()) {
+     std::string error;
+     CephXAuthorizeChallenge ch;
+  decode_decrypt_enc_bl(cct, ch, session_key, challenge, error);
+  if (!error.empty()) {
+  ldout(cct, 0) << "failed to decrypt challenge (" << challenge.length() << " bytes): "
+ 		    << error << dendl;
+  return false;
+     }
+     msg.have_challenge = true;
+     msg.server_challenge_plus_one = ch.server_challenge + 1;
+   }
+ 
+   std::string error;
+  if (encode_encrypt(cct, msg, session_key, bl, error)) {
+  ldout(cct, 0) << __func__ << " failed to encrypt authorizer: " << error << dendl;
+  return false;
+   }
+  return true;
+ }
  @@ -273,12 +273,14 @@ struct CephXAuthorizer : public AuthAuthorizer {
    CephContext *cct;
  public:
   uint64_t nonce;
+   bufferlist base_bl;
  
   explicit CephXAuthorizer(CephContext *cct_)
      : AuthAuthorizer(CEPH_AUTH_CEPHX), cct(cct_), nonce(0) {}
  
   bool build_authorizer();
   bool verify_reply(bufferlist::iterator& reply) override;
+  bool add_challenge(CephContext *cct, bufferlist& challenge) override;
  };
  
  
  @@ -384,17 +386,41 @@ struct CephXServiceTicketInfo {
  };
  WRITE_CLASS_ENCODER(CephXServiceTicketInfo)
  
+ struct CephXAuthorizeChallenge : public AuthAuthorizerChallenge {
+  uint64_t server_challenge;
+  void encode(bufferlist& bl) const {
+     __u8 struct_v = 1;
+  ::encode(struct_v, bl);
+  ::encode(server_challenge, bl);
+   }
+  void decode(bufferlist::iterator& bl) {
+     __u8 struct_v;
+  ::decode(struct_v, bl);
+  ::decode(server_challenge, bl);
+   }
+ };
+ WRITE_CLASS_ENCODER(CephXAuthorizeChallenge)
+ 
  struct CephXAuthorize {
   uint64_t nonce;
+  bool have_challenge = false;
+  uint64_t server_challenge_plus_one = 0;
   void encode(bufferlist& bl) const {
-     __u8 struct_v = 1;
+     __u8 struct_v = 2;
   ::encode(struct_v, bl);
   ::encode(nonce, bl);
+  ::encode(have_challenge, bl);
+  ::encode(server_challenge_plus_one, bl);
    }
   void decode(bufferlist::iterator& bl) {
      __u8 struct_v;
   ::decode(struct_v, bl);
   ::decode(nonce, bl);
+  if (struct_v >= 2) {
+  ::decode(have_challenge, bl);
+  ::decode(server_challenge_plus_one, bl);
+     }
+ 
    }
  };
  WRITE_CLASS_ENCODER(CephXAuthorize)
  @@ -409,9 +435,12 @@ bool cephx_decode_ticket(CephContext *cct, KeyStore *keys,
  /*
   * Verify authorizer and generate reply authorizer
   */
- extern bool cephx_verify_authorizer(CephContext *cct, KeyStore *keys,
- 				    bufferlist::iterator& indata,
- 				    CephXServiceTicketInfo& ticket_info, bufferlist& reply_bl);
+ extern bool cephx_verify_authorizer(
+   CephContext *cct, KeyStore *keys,
+   bufferlist::iterator& indata,
+   CephXServiceTicketInfo& ticket_info,
+   std::unique_ptr<AuthAuthorizerChallenge> *challenge,
+   bufferlist& reply_bl);
  
  
  
  
  @@ -152,7 +152,9 @@ int CephxServiceHandler::handle_request(bufferlist::iterator& indata, bufferlist
  
        bufferlist tmp_bl;
        CephXServiceTicketInfo auth_ticket_info;
-  if (!cephx_verify_authorizer(cct, key_server, indata, auth_ticket_info, tmp_bl)) {
+  // note: no challenge here.
+  if (!cephx_verify_authorizer(cct, key_server, indata, auth_ticket_info, nullptr,
+ 				   tmp_bl)) {
          ret = -EPERM;
   break;
        }
  
  @@ -17,10 +17,13 @@
  
  #define dout_subsys ceph_subsys_auth
  
- bool AuthNoneAuthorizeHandler::verify_authorizer(CephContext *cct, KeyStore *keys,
- 						 bufferlist& authorizer_data, bufferlist& authorizer_reply,
- 						 EntityName& entity_name, uint64_t& global_id, AuthCapsInfo& caps_info, CryptoKey& session_key,
- uint64_t *auid)
+ bool AuthNoneAuthorizeHandler::verify_authorizer(
+   CephContext *cct, KeyStore *keys,
+   bufferlist& authorizer_data, bufferlist& authorizer_reply,
+   EntityName& entity_name, uint64_t& global_id, AuthCapsInfo& caps_info,
+   CryptoKey& session_key,
+  uint64_t *auid,
+   std::unique_ptr<AuthAuthorizerChallenge> *challenge)
  {
    bufferlist::iterator iter = authorizer_data.begin();
  
  
  @@ -23,7 +23,8 @@ struct AuthNoneAuthorizeHandler : public AuthAuthorizeHandler {
   bool verify_authorizer(CephContext *cct, KeyStore *keys,
  			 bufferlist& authorizer_data, bufferlist& authorizer_reply,
                           EntityName& entity_name, uint64_t& global_id,
- 			 AuthCapsInfo& caps_info, CryptoKey& session_key, uint64_t *auid=NULL) override;
+ 			 AuthCapsInfo& caps_info, CryptoKey& session_key, uint64_t *auid,
+ 			 std::unique_ptr<AuthAuthorizerChallenge> *challenge) override;
   int authorizer_session_crypto() override;
  };
  
  
  @@ -17,6 +17,8 @@
  
  #include "auth/Auth.h"
  
+ class CephContext;
+ 
  struct AuthNoneAuthorizer : public AuthAuthorizer {
   AuthNoneAuthorizer() : AuthAuthorizer(CEPH_AUTH_NONE) { }
   bool build_authorizer(const EntityName &ename, uint64_t global_id) {
  @@ -27,6 +29,7 @@ struct AuthNoneAuthorizer : public AuthAuthorizer {
   return 0;
    }
   bool verify_reply(bufferlist::iterator& reply) override { return true; }
+  bool add_challenge(CephContext *cct, bufferlist& ch) override { return true; }
  };
  
  #endif
  @@ -14,10 +14,13 @@
  
  #include "AuthUnknownAuthorizeHandler.h"
  
- bool AuthUnknownAuthorizeHandler::verify_authorizer(CephContext *cct, KeyStore *keys,
- 						 bufferlist& authorizer_data, bufferlist& authorizer_reply,
- 						 EntityName& entity_name, uint64_t& global_id, AuthCapsInfo& caps_info, CryptoKey& session_key,
- uint64_t *auid)
+ bool AuthUnknownAuthorizeHandler::verify_authorizer(
+   CephContext *cct, KeyStore *keys,
+   bufferlist& authorizer_data, bufferlist& authorizer_reply,
+   EntityName& entity_name, uint64_t& global_id, AuthCapsInfo& caps_info,
+   CryptoKey& session_key,
+  uint64_t *auid,
+   std::unique_ptr<AuthAuthorizerChallenge> *challenge)
  {
   // For unknown authorizers, there's nothing to verify.  They're "OK" by definition.  PLR
  
  
  @@ -23,7 +23,8 @@ struct AuthUnknownAuthorizeHandler : public AuthAuthorizeHandler {
   bool verify_authorizer(CephContext *cct, KeyStore *keys,
  			 bufferlist& authorizer_data, bufferlist& authorizer_reply,
                           EntityName& entity_name, uint64_t& global_id,
- 			 AuthCapsInfo& caps_info, CryptoKey& session_key, uint64_t *auid=NULL) override;
+ 			 AuthCapsInfo& caps_info, CryptoKey& session_key, uint64_t *auid,
+ 			 std::unique_ptr<AuthAuthorizerChallenge> *challenge) override;
   int authorizer_session_crypto() override;
  };
  
  
  @@ -93,7 +93,7 @@ struct ceph_entity_inst {
  #define CEPH_MSGR_TAG_SEQ 13 /* 64-bit int follows with seen seq number */
  #define CEPH_MSGR_TAG_KEEPALIVE2 14
  #define CEPH_MSGR_TAG_KEEPALIVE2_ACK 15 /* keepalive reply */
- 
+ #define CEPH_MSGR_TAG_CHALLENGE_AUTHORIZER 16 /* ceph v2 doing server challenge */
  
  /*
   * connection negotiation
  
  @@ -1262,7 +1262,8 @@ bool MDSDaemon::ms_handle_refused(Connection *con)
  
  bool MDSDaemon::ms_verify_authorizer(Connection *con, int peer_type,
   int protocol, bufferlist& authorizer_data, bufferlist& authorizer_reply,
-  bool& is_valid, CryptoKey& session_key)
+  bool& is_valid, CryptoKey& session_key,
+ 				     std::unique_ptr<AuthAuthorizerChallenge> *challenge)
  {
    Mutex::Locker l(mds_lock);
   if (stopping) {
  @@ -1294,7 +1295,7 @@ bool MDSDaemon::ms_verify_authorizer(Connection *con, int peer_type,
      is_valid = authorize_handler->verify_authorizer(
        cct, keys,
        authorizer_data, authorizer_reply, name, global_id, caps_info,
-       session_key);
+       session_key, nullptr, challenge);
    } else {
   dout(10) << __func__ << " no rotating_keys (yet), denied" << dendl;
      is_valid = false;
  
  @@ -108,7 +108,8 @@ class MDSDaemon : public Dispatcher, public md_config_obs_t {
   bool ms_get_authorizer(int dest_type, AuthAuthorizer **authorizer, bool force_new) override;
   bool ms_verify_authorizer(Connection *con, int peer_type,
   int protocol, bufferlist& authorizer_data, bufferlist& authorizer_reply,
-  bool& isvalid, CryptoKey& session_key) override;
+  bool& isvalid, CryptoKey& session_key,
+ 			    std::unique_ptr<AuthAuthorizerChallenge> *challenge) override;
   void ms_handle_accept(Connection *con) override;
   void ms_handle_connect(Connection *con) override;
   bool ms_handle_reset(Connection *con) override;
  
  @@ -141,13 +141,15 @@ entity_addr_t DaemonServer::get_myaddr() const
  }
  
  
- bool DaemonServer::ms_verify_authorizer(Connection *con,
-  int peer_type,
-  int protocol,
-     ceph::bufferlist& authorizer_data,
-     ceph::bufferlist& authorizer_reply,
-  bool& is_valid,
-     CryptoKey& session_key)
+ bool DaemonServer::ms_verify_authorizer(
+   Connection *con,
+  int peer_type,
+  int protocol,
+   ceph::bufferlist& authorizer_data,
+   ceph::bufferlist& authorizer_reply,
+  bool& is_valid,
+   CryptoKey& session_key,
+   std::unique_ptr<AuthAuthorizerChallenge> *challenge)
  {
    AuthAuthorizeHandler *handler = nullptr;
   if (peer_type == CEPH_ENTITY_TYPE_OSD ||
  @@ -175,7 +177,9 @@ bool DaemonServer::ms_verify_authorizer(Connection *con,
        authorizer_data,
        authorizer_reply, s->entity_name,
        s->global_id, caps_info,
-       session_key);
+       session_key,
+  nullptr,
+       challenge);
    } else {
   dout(10) << __func__ << " no rotating_keys (yet), denied" << dendl;
      is_valid = false;
  
  @@ -123,13 +123,15 @@ class DaemonServer : public Dispatcher, public md_config_obs_t
   bool ms_handle_refused(Connection *con) override;
   bool ms_get_authorizer(int dest_type, AuthAuthorizer **authorizer,
   bool force_new) override;
-  bool ms_verify_authorizer(Connection *con,
-  int peer_type,
-  int protocol,
-       ceph::bufferlist& authorizer,
-       ceph::bufferlist& authorizer_reply,
-  bool& isvalid,
-       CryptoKey& session_key) override;
+  bool ms_verify_authorizer(
+     Connection *con,
+  int peer_type,
+  int protocol,
+     ceph::bufferlist& authorizer,
+     ceph::bufferlist& authorizer_reply,
+  bool& isvalid,
+     CryptoKey& session_key,
+     std::unique_ptr<AuthAuthorizerChallenge> *challenge) override;
  
   bool handle_open(MMgrOpen *m);
   bool handle_report(MMgrReport *m);
  
