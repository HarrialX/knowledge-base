Original Source:
https://github.com/gophish/gophish/commit/e3352f481e94054ffe08494c9225d3878347b005

Commit history:

  @@ -9,11 +9,12 @@ import (
  
  // AdminServer represents the Admin server configuration details
  type AdminServer struct {
-  ListenURL string `json:"listen_url"`
-  UseTLS bool `json:"use_tls"`
-  CertPath string `json:"cert_path"`
-  KeyPath string `json:"key_path"`
-  CSRFKey string `json:"csrf_key"`
+  ListenURL string `json:"listen_url"`
+  UseTLS bool `json:"use_tls"`
+  CertPath string `json:"cert_path"`
+  KeyPath string `json:"key_path"`
+  CSRFKey string `json:"csrf_key"`
+  AllowedInternalHosts []string `json:"allowed_internal_hosts"`
  }
  
  // PhishServer represents the Phish server configuration details
  
  @@ -10,6 +10,7 @@ import (
   "strings"
  
   "github.com/PuerkitoBio/goquery"
+  "github.com/gophish/gophish/dialer"
  	log "github.com/gophish/gophish/logger"
   "github.com/gophish/gophish/models"
   "github.com/gophish/gophish/util"
  @@ -113,7 +114,9 @@ func (as *Server) ImportSite(w http.ResponseWriter, r *http.Request) {
   JSONResponse(w, models.Response{Success: false, Message: err.Error()}, http.StatusBadRequest)
   return
  	}
+  restrictedDialer := dialer.Dialer()
   tr := &http.Transport{
+  DialContext: restrictedDialer.DialContext,
   TLSClientConfig: &tls.Config{
   InsecureSkipVerify: true,
  		},
  
  @@ -0,0 +1,84 @@
+ package api
+ 
+ import (
+  "bytes"
+  "encoding/json"
+  "fmt"
+  "net/http"
+  "net/http/httptest"
+  "strings"
+  "testing"
+ 
+  "github.com/gophish/gophish/dialer"
+  "github.com/gophish/gophish/models"
+ )
+ 
+ func makeImportRequest(ctx *testContext, allowedHosts []string, url string) *httptest.ResponseRecorder {
+  orig := dialer.DefaultDialer.AllowedHosts()
+  dialer.SetAllowedHosts(allowedHosts)
+  req := httptest.NewRequest(http.MethodPost, "/api/import/site",
+  bytes.NewBuffer([]byte(fmt.Sprintf(`
+ 			{
+ 				"url" : "%s"
+ 			}
+ 		`, url))))
+  req.Header.Set("Content-Type", "application/json")
+  response := httptest.NewRecorder()
+  ctx.apiServer.ImportSite(response, req)
+  dialer.SetAllowedHosts(orig)
+  return response
+ }
+ 
+ func TestDefaultDeniedImport(t *testing.T) {
+  ctx := setupTest(t)
+  metadataURL := "http://169.254.169.254/latest/meta-data/"
+  response := makeImportRequest(ctx, []string{}, metadataURL)
+  expectedCode := http.StatusBadRequest
+  if response.Code != expectedCode {
+  t.Fatalf("incorrect status code received. expected %d got %d", expectedCode, response.Code)
+ 	}
+  got := &models.Response{}
+  err := json.NewDecoder(response.Body).Decode(got)
+  if err != nil {
+  t.Fatalf("error decoding body: %v", err)
+ 	}
+  if !strings.Contains(got.Message, "upstream connection denied") {
+  t.Fatalf("incorrect response error provided: %s", got.Message)
+ 	}
+ }
+ 
+ func TestDefaultAllowedImport(t *testing.T) {
+  ctx := setupTest(t)
+  h := "<html><head></head><body><img src=\"/test.png\"/></body></html>"
+  ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+  fmt.Fprintln(w, h)
+ 	}))
+  defer ts.Close()
+  response := makeImportRequest(ctx, []string{}, ts.URL)
+  expectedCode := http.StatusOK
+  if response.Code != expectedCode {
+  t.Fatalf("incorrect status code received. expected %d got %d", expectedCode, response.Code)
+ 	}
+ }
+ 
+ func TestCustomDeniedImport(t *testing.T) {
+  ctx := setupTest(t)
+  h := "<html><head></head><body><img src=\"/test.png\"/></body></html>"
+  ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+  fmt.Fprintln(w, h)
+ 	}))
+  defer ts.Close()
+  response := makeImportRequest(ctx, []string{"192.168.1.1"}, ts.URL)
+  expectedCode := http.StatusBadRequest
+  if response.Code != expectedCode {
+  t.Fatalf("incorrect status code received. expected %d got %d", expectedCode, response.Code)
+ 	}
+  got := &models.Response{}
+  err := json.NewDecoder(response.Body).Decode(got)
+  if err != nil {
+  t.Fatalf("error decoding body: %v", err)
+ 	}
+  if !strings.Contains(got.Message, "upstream connection denied") {
+  t.Fatalf("incorrect response error provided: %s", got.Message)
+ 	}
+ }
  @@ -0,0 +1,158 @@
+ package dialer
+ 
+ import (
+  "fmt"
+  "net"
+  "syscall"
+  "time"
+ )
+ 
+ // RestrictedDialer is used to create a net.Dialer which restricts outbound
+ // connections to only allowlisted IP ranges.
+ type RestrictedDialer struct {
+  allowedHosts []*net.IPNet
+ }
+ 
+ // DefaultDialer is a global instance of a RestrictedDialer
+ var DefaultDialer = &RestrictedDialer{}
+ 
+ // SetAllowedHosts sets the list of allowed hosts or IP ranges for the default
+ // dialer.
+ func SetAllowedHosts(allowed []string) {
+  DefaultDialer.SetAllowedHosts(allowed)
+ }
+ 
+ // AllowedHosts returns the configured hosts that are allowed for the dialer.
+ func (d *RestrictedDialer) AllowedHosts() []string {
+  ranges := []string{}
+  for _, ipRange := range d.allowedHosts {
+  ranges = append(ranges, ipRange.String())
+ 	}
+  return ranges
+ }
+ 
+ // SetAllowedHosts sets the list of allowed hosts or IP ranges for the dialer.
+ func (d *RestrictedDialer) SetAllowedHosts(allowed []string) error {
+  for _, ipRange := range allowed {
+  // For flexibility, try to parse as an IP first since this will
+  // undoubtedly cause issues. If it works, then just append the
+  // appropriate subnet mask, then parse as CIDR
+  if singleIP := net.ParseIP(ipRange); singleIP != nil {
+  if singleIP.To4() != nil {
+  ipRange += "/32"
+ 			} else {
+  ipRange += "/128"
+ 			}
+ 		}
+  _, parsed, err := net.ParseCIDR(ipRange)
+  if err != nil {
+  return fmt.Errorf("provided ip range is not valid CIDR notation: %v", err)
+ 		}
+  d.allowedHosts = append(d.allowedHosts, parsed)
+ 	}
+  return nil
+ }
+ 
+ // Dialer returns a net.Dialer that restricts outbound connections to only the
+ // addresses allowed by the DefaultDialer.
+ func Dialer() *net.Dialer {
+  return DefaultDialer.Dialer()
+ }
+ 
+ // Dialer returns a net.Dialer that restricts outbound connections to only the
+ // allowed addresses over TCP.
+ //
+ // By default, since Gophish anticipates connections originating to hosts on
+ // the local network, we only deny access to the link-local addresses at
+ // 169.254.0.0/16.
+ //
+ // If hosts are provided, then Gophish blocks access to all local addresses
+ // except the ones provided.
+ //
+ // This implementation is based on the blog post by Andrew Ayer at
+ // https://www.agwa.name/blog/post/preventing_server_side_request_forgery_in_golang
+ func (d *RestrictedDialer) Dialer() *net.Dialer {
+  return &net.Dialer{
+  Timeout:   30 * time.Second,
+  KeepAlive: 30 * time.Second,
+  Control:   restrictedControl(d.allowedHosts),
+ 	}
+ }
+ 
+ // defaultDeny represents the list of IP ranges that we want to block unless
+ // explicitly overriden.
+ var defaultDeny = []string{
+  "169.254.0.0/16", // Link-local (used for VPS instance metadata)
+ }
+ 
+ // allInternal represents all internal hosts such that the only connections
+ // allowed are external ones.
+ var allInternal = []string{
+  "0.0.0.0/8",
+  "127.0.0.0/8",        // IPv4 loopback
+  "10.0.0.0/8",         // RFC1918
+  "100.64.0.0/10",      // CGNAT
+  "172.16.0.0/12",      // RFC1918
+  "169.254.0.0/16",     // RFC3927 link-local
+  "192.88.99.0/24",     // IPv6 to IPv4 Relay
+  "192.168.0.0/16",     // RFC1918
+  "198.51.100.0/24",    // TEST-NET-2
+  "203.0.113.0/24",     // TEST-NET-3
+  "224.0.0.0/4",        // Multicast
+  "240.0.0.0/4",        // Reserved
+  "255.255.255.255/32", // Broadcast
+  "::/0",               // Default route
+  "::/128",             // Unspecified address
+  "::1/128",            // IPv6 loopback
+  "::ffff:0:0/96",      // IPv4 mapped addresses.
+  "::ffff:0:0:0/96",    // IPv4 translated addresses.
+  "fe80::/10",          // IPv6 link-local
+  "fc00::/7",           // IPv6 unique local addr
+ }
+ 
+ type dialControl = func(network, address string, c syscall.RawConn) error
+ 
+ type restrictedDialer struct {
+  *net.Dialer
+  allowed []string
+ }
+ 
+ func restrictedControl(allowed []*net.IPNet) dialControl {
+  return func(network string, address string, conn syscall.RawConn) error {
+  if !(network == "tcp4" || network == "tcp6") {
+  return fmt.Errorf("%s is not a safe network type", network)
+ 		}
+ 
+  host, _, err := net.SplitHostPort(address)
+  if err != nil {
+  return fmt.Errorf("%s is not a valid host/port pair: %s", address, err)
+ 		}
+ 
+  ip := net.ParseIP(host)
+  if ip == nil {
+  return fmt.Errorf("%s is not a valid IP address", host)
+ 		}
+ 
+  denyList := defaultDeny
+  if len(allowed) > 0 {
+  denyList = allInternal
+ 		}
+ 
+  for _, ipRange := range allowed {
+  if ipRange.Contains(ip) {
+  return nil
+ 			}
+ 		}
+ 
+  for _, ipRange := range denyList {
+  _, parsed, err := net.ParseCIDR(ipRange)
+  if err != nil {
+  return fmt.Errorf("error parsing denied range: %v", err)
+ 			}
+  if parsed.Contains(ip) {
+  return fmt.Errorf("upstream connection denied to internal host")
+ 			}
+ 		}
+  return nil
+ 	}
+ }
  @@ -0,0 +1,85 @@
+ package dialer
+ 
+ import (
+  "fmt"
+  "net"
+  "strings"
+  "syscall"
+  "testing"
+ )
+ 
+ func TestDefaultDeny(t *testing.T) {
+  control := restrictedControl([]*net.IPNet{})
+  host := "169.254.169.254"
+  expected := fmt.Errorf("upstream connection denied to internal host at %s", host)
+  conn := new(syscall.RawConn)
+  got := control("tcp4", fmt.Sprintf("%s:80", host), *conn)
+  if !strings.Contains(got.Error(), "upstream connection denied") {
+  t.Fatalf("unexpected error dialing denylisted host. expected %v got %v", expected, got)
+ 	}
+ }
+ 
+ func TestDefaultAllow(t *testing.T) {
+  control := restrictedControl([]*net.IPNet{})
+  host := "1.1.1.1"
+  conn := new(syscall.RawConn)
+  got := control("tcp4", fmt.Sprintf("%s:80", host), *conn)
+  if got != nil {
+  t.Fatalf("error dialing allowed host. got %v", got)
+ 	}
+ }
+ 
+ func TestCustomAllow(t *testing.T) {
+  host := "127.0.0.1"
+  _, ipRange, _ := net.ParseCIDR(fmt.Sprintf("%s/32", host))
+  allowed := []*net.IPNet{ipRange}
+  control := restrictedControl(allowed)
+  conn := new(syscall.RawConn)
+  got := control("tcp4", fmt.Sprintf("%s:80", host), *conn)
+  if got != nil {
+  t.Fatalf("error dialing allowed host. got %v", got)
+ 	}
+ }
+ 
+ func TestCustomDeny(t *testing.T) {
+  host := "127.0.0.1"
+  _, ipRange, _ := net.ParseCIDR(fmt.Sprintf("%s/32", host))
+  allowed := []*net.IPNet{ipRange}
+  control := restrictedControl(allowed)
+  conn := new(syscall.RawConn)
+  expected := fmt.Errorf("upstream connection denied to internal host at %s", host)
+  got := control("tcp4", "192.168.1.2:80", *conn)
+  if !strings.Contains(got.Error(), "upstream connection denied") {
+  t.Fatalf("unexpected error dialing denylisted host. expected %v got %v", expected, got)
+ 	}
+ }
+ 
+ func TestSingleIP(t *testing.T) {
+  orig := DefaultDialer.AllowedHosts()
+  host := "127.0.0.1"
+  DefaultDialer.SetAllowedHosts([]string{host})
+  control := DefaultDialer.Dialer().Control
+  conn := new(syscall.RawConn)
+  expected := fmt.Errorf("upstream connection denied to internal host at %s", host)
+  got := control("tcp4", "192.168.1.2:80", *conn)
+  if !strings.Contains(got.Error(), "upstream connection denied") {
+  t.Fatalf("unexpected error dialing denylisted host. expected %v got %v", expected, got)
+ 	}
+ 
+  host = "::1"
+  DefaultDialer.SetAllowedHosts([]string{host})
+  control = DefaultDialer.Dialer().Control
+  conn = new(syscall.RawConn)
+  expected = fmt.Errorf("upstream connection denied to internal host at %s", host)
+  got = control("tcp4", "192.168.1.2:80", *conn)
+  if !strings.Contains(got.Error(), "upstream connection denied") {
+  t.Fatalf("unexpected error dialing denylisted host. expected %v got %v", expected, got)
+ 	}
+ 
+  // Test an allowed connection
+  got = control("tcp4", fmt.Sprintf("[%s]:80", host), *conn)
+  if got != nil {
+  t.Fatalf("error dialing allowed host. got %v", got)
+ 	}
+  DefaultDialer.SetAllowedHosts(orig)
+ }
  @@ -11,7 +11,7 @@ require (
  	github.com/emersion/go-imap v1.0.4
  	github.com/emersion/go-message v0.12.0
  	github.com/go-sql-driver/mysql v1.5.0
- 	github.com/gophish/gomail v0.0.0-20180314010319-cf7e1a5479be
+ 	github.com/gophish/gomail v0.0.0-20200818021916-1f6d0dfd512e
  	github.com/gorilla/context v1.1.1
  	github.com/gorilla/csrf v1.6.2
  	github.com/gorilla/handlers v1.4.2
  @@ -29,7 +29,5 @@ require (
  	golang.org/x/crypto v0.0.0-20200128174031-69ecbb4d6d5d
  	golang.org/x/time v0.0.0-20200416051211-89c76fbcd5d1
  	gopkg.in/alecthomas/kingpin.v2 v2.2.6
- 	gopkg.in/alexcesaro/quotedprintable.v3 v3.0.0-20150716171945-2caba252f4dc // indirect
  	gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405
- 	gopkg.in/gomail.v2 v2.0.0-20160411212932-81ebce5c23df // indirect
  )
