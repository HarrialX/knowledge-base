Original Source:
https://github.com/glennrp/libpng/commit/8a05766cb74af05c04c53e6c9d60c13fc4d59bf2

Commit history:

  @@ -3167,10 +3167,13 @@ png_check_chunk_length(png_const_structrp png_ptr, const png_uint_32 length)
     {
   png_alloc_size_t idat_limit = PNG_UINT_31_MAX;
   size_t row_factor =
-          (png_ptr->width * png_ptr->channels * (png_ptr->bit_depth > 8? 2: 1)
-           + 1 + (png_ptr->interlaced? 6: 0));
+          (size_t)png_ptr->width
+          * (size_t)png_ptr->channels
+          * (png_ptr->bit_depth > 8? 2: 1)
+          + 1
+          + (png_ptr->interlaced? 6: 0);
                This comment has been minimized.

        

Sign in to view
















              Copy link
            

              Quote reply
            









dgutson



Jul 12, 2018





You can still get a 0 with the following values:
png_ptr->width = (size_t)-1;
png_ptr->channels = 1;
png_ptr->bit_depth = 1;
png_ptr->interlaced = 0;
   if (png_ptr->height > PNG_UINT_32_MAX/row_factor)
                This comment has been minimized.

        

Sign in to view
















              Copy link
            

              Quote reply
            









dgutson



Jul 12, 2018





..so I suggest to add a sanitizing check here that row_factor > 0 before doing the division.
-          idat_limit=PNG_UINT_31_MAX;
+          idat_limit = PNG_UINT_31_MAX;
   else
           idat_limit = png_ptr->height * row_factor;
        row_factor = row_factor > 32566? 32566 : row_factor;
  
