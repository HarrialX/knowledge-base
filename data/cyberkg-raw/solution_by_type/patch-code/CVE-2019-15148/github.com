Original Source:
https://github.com/gopro/gpmf-parser/commit/341f12cd5b97ab419e53853ca00176457c9f1681

Commit history:

  @@ -2,7 +2,7 @@
   * 
   *  @brief GPMF Parser library
   *
-  *  @version 1.2.1
+  *  @version 1.2.2
   * 
   *  (C) Copyright 2017 GoPro Inc (http://gopro.com/).
   *	
  @@ -42,7 +42,7 @@ GPMF_ERR IsValidSize(GPMF_stream *ms, uint32_t size) // size is in longs not byt
  {
   if (ms)
  	{
-  int32_t nestsize = (int32_t)ms->nest_size[ms->nest_level];
+  uint32_t nestsize = (uint32_t)ms->nest_size[ms->nest_level];
   if (nestsize == 0 && ms->nest_level == 0)
  			nestsize = ms->buffer_size_longs;
  
  
  @@ -2,7 +2,7 @@
   * 
   *  @brief GPMF Parser library include
   * 
-  *  @version 1.1.0
+  *  @version 1.1.1
   * 
   *  (C) Copyright 2017 GoPro Inc (http://gopro.com/).
   *	
  @@ -126,7 +126,11 @@ typedef enum GPMFKey // TAG in all caps are GoPro preserved (are defined by GoPr
  	GPMF_KEY_UNITS =			MAKEID('U','N','I','T'),//UNIT - Freedform display string for metadata units (char sting like "RPM", "MPH", "km/h", etc)
  	GPMF_KEY_SCALE =			MAKEID('S','C','A','L'),//SCAL - divisor for input data to scale to the correct units.
  	GPMF_KEY_TYPE =				MAKEID('T','Y','P','E'),//TYPE - Type define for complex data structures
- 	GPMF_KEY_TOTAL_SAMPLES =	MAKEID('T','S','M','P'),//TOTL - Total Sample Count including the current payload 	
+ 	GPMF_KEY_TOTAL_SAMPLES =	MAKEID('T','S','M','P'),//TSMP - Total Sample Count including the current payload 	
+ 	GPMF_KEY_TIME_OFFSET =		MAKEID('T','I','M','O'),//TIMO - Time offset of the metadata stream that follows (single 4 byte float)
+ 	GPMF_KEY_TIMING_OFFSET =	MAKEID('T','I','M','O'),//TIMO - duplicated, as older code might use the other version of TIMO
+ 	GPMF_KEY_TIME_STAMP =		MAKEID('S','T','M','P'),//STMP - Time stamp for the first sample. 
+ 	GPMF_KEY_TIME_STAMPS =		MAKEID('S','T','P','S'),//STPS - Stream of all the timestamps delivered (Generally don't use this. This would be if your sensor has no peroidic times, yet precision is required, or for debugging.) 
  	GPMF_KEY_TICK =				MAKEID('T','I','C','K'),//TICK - Used for slow data. Beginning of data timing in milliseconds. 
  	GPMF_KEY_TOCK =				MAKEID('T','O','C','K'),//TOCK - Used for slow data. End of data timing in milliseconds. 
  	GPMF_KEY_EMPTY_PAYLOADS =	MAKEID('E','M','P','T'),//EMPT - Payloads that are empty since the device start (e.g. BLE disconnect.)
  
  @@ -46,6 +46,12 @@ int main(int argc, char *argv[])
  	}
  
   size_t mp4 = OpenMP4Source(argv[1], MOV_GPMF_TRAK_TYPE, MOV_GPMF_TRAK_SUBTYPE);
+  if (mp4 == 0)
+ 	{
+  printf("error: %s is an invalid MP4/MOV\n", argv[1]);
+  return -1;
+ 	}
+ 
  //	size_t mp4 = OpenMP4SourceUDTA(argv[1]);  //Search for GPMF payload with MP4's udta 
  
  	metadatalength = GetDuration(mp4);
  @@ -90,7 +96,7 @@ int main(int argc, char *argv[])
   for (index = 0; index < payloads; index++)
  		{
   uint32_t payloadsize = GetPayloadSize(mp4, index);
-  float in = 0.0, out = 0.0; //times
+  double in = 0.0, out = 0.0; //times
  			payload = GetPayload(mp4, payload, index);
   if (payload == NULL)
   goto cleanup;
  @@ -238,9 +244,10 @@ int main(int argc, char *argv[])
  		{
   if (GPMF_OK == GPMF_SeekToSamples(ms)) //find the last FOURCC within the stream
  			{
+  double in = 0.0, out = 0.0;
   uint32_t fourcc = GPMF_Key(ms);
-  double rate = GetGPMFSampleRate(mp4, fourcc, GPMF_SAMPLE_RATE_PRECISE);// GPMF_SAMPLE_RATE_FAST);
-  printf("%c%c%c%c sampling rate = %f Hz\n", PRINTF_4CC(fourcc), rate);
+  double rate = GetGPMFSampleRate(mp4, fourcc, GPMF_SAMPLE_RATE_PRECISE, &in, &out);// GPMF_SAMPLE_RATE_FAST);
+  printf("%c%c%c%c sampling rate = %f Hz (from %f to %f)\n", PRINTF_4CC(fourcc), rate, in, out);
  			}
  		}
  #endif
  
